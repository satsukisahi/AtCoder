//warshallfloyd
//隣接行列
int v;         //頂点数
int d[v][v]; //d[u][v]はuからvへコスト　存在しないとINF、d[i][i]=0

void warshallfloyd()
{
    for (int k = 0; k < v; k++)
        for (int i = 0; i < v; i++)
            for (int j = 0; j < v; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

//Dijkstra
//pair.first=距離,pair.second=点
priority_queue< pair<ll,ll>, vector<pair<ll,ll>>, greater<pair<ll,ll>> > q;
vector<ll> dist(n, INF);
q.push({0,初期位置});

while (!q.empty()){
    pair<ll,ll> p=q.top();q.pop();
    ll v=p.second; //見る点
    if(dist[v]<p.first)continue; //その点が現状の最短より長いなら終了
    rep(i,G[v].size()){
        edge e=G[v][i];
        if(dist[e.to]>dist[v]+e.cost){
            dist[e.to]=dist[v]+e.cost;
            q.push({dist[e.to],e.to});
        }
    }
}

//木dfs
void dfs(ll x, vector<vector<edge>> &g, bool *see)
{
    //点xに対する処理
    see[x] = 1;
    for (auto p : g[x])
    {
        if (see[p.to])
            continue;
        //進む辺に対する処理
        dfs(p.to, g, see);
        //戻る辺に対する処理
    }
}