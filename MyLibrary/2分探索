//upperは常に条件を満たすlowerは常に条件を満たさない
//条件を満たす最小のindexを返す

int lower=下限のindex,upper=上限のindex;
int seenow,oklowest;
bool ok2butan;
while(true){
seenow=(lower+upper)/2;

//todo:seenowに対して処理
//条件を満たすならok2butan=trueにする

if(ok2butan){
    upper=seenow;
    if(upper==lower+1){oklowest=seenow;break;}
    }
else {
    lower=seenow;
    if(upper==lower+1){oklowest=seenow+1;break;}
    }
}

//STL
sort済みの配列、vectorで
vector<int> a = {1, 4, 4, 7, 7, 8, 8, 11, 13, 19};

key以上の要素の内の一番左側のイテレータを返す
auto itr = lower_bound(a.begin(),a.end(), 7);
cout << itr - a.begin() << endl; // 3となる

keyより大きい要素の内の一番左側のイテレータを返す
auto itr = upper_bound(a.begin(),a.end(), 7);
cout << itr - a.begin() << endl; // 5となる

差をとれば個数が分かる
upper_bound(a.begin(),a.end(), hoge)-lower_bound(a.begin(),a.end(), hoge);

//凸関数の3分探索
//下に凸で最小値を求める場合
double lower=0,upper=1000000000;
double x1,x2;

while(true){
    x1=(upper-lower)/3+lower;
    x2=(upper-lower)*2/3+lower;
    if(x1での値>x2での値)lower=x1;
    else upper=x2;

    if(x2-x1<0.00000000001){
        ans=(x1+x2)/2;
        break;
    }
}