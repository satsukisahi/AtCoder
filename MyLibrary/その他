//エリア内か確認するときなど
bool inarea(ll x,ll y){
  return x >= 0 && y >= 0 && x < h && y < w ;
}

//構造体
struct point {
    ll x,y,val;
    point() {}
    point(ll x, ll y, ll val) : x(x), y(y), val(val) {};
};
struct point {
    ll x,y;
    point() {}
    point(ll x, ll y) : x(x), y(y) {};
};

//sort用の比較関数　>なら降順 xの昇順で同じときyの昇順
bool cmp(const point &a, const point &b)
{
  return a.val > b.val;
}

//bit全探索
d=個数
//0から2^d乗まで
for (ll) bit = 0; bit < (1<<d); ++bit) {
//各ビットを下から見ていく
  rep(j,d){
//jビット目が1なら処理を行う
    if(bit>>j&1){
      todo;
    }
  }
}

//グラフdfs
void dfs(ll x, vector<vector<edge>> &g, bool *see)
{
  //点xに対する処理
  see[x] = 1;
  for (auto p : g[x])
  {
    if (see[p.to])
        continue;
    //進む辺に対する処理（これは木構造でオイラーツアーするために使う）
    dfs(p.to, g, see);
    //戻る辺に対する処理
  }
  //点xの親に戻る時の処理
}

//dfsスタックでやるとき
stack<ll> s;
bool see[n]={};
s.push(0);//スタート
s.push(0);
while(s.size()!=0){
  ll now=s.top();
  s.pop();
  if(!see[now]){
    see[now]=1;
    //訪れた点に対する処理
    for (auto p : g[now])
    {
      if (see[p])
          continue;
      s.push(p);
      s.push(p);
    }
  }
  else{
    //去る点に対する処理
  }
}

//ダブリング
//構築
vector<vector<ll>> dub(20, vector<ll>(n,0));
//dub[0][i]にiの次のインデックスを入れる　なければ-1
rep(i,19){
  rep(j,n){
    if(dub[i][j]==-1)dub[i+1][j]=-1;
    else dub[i+1][j]=dub[i][dub[i][j]];
  }
}
//二分探索 上界か下界かを意識
 for (ll i = 20; i >= 0; i--)
{
  if(0<dub[i][a] && インデックスdub[i][a](つまりa+2^i)が条件を満たすか　){
    ans+=1LL<<i;
    a=dub[i][a];
  }
}