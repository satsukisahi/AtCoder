//エリア内か確認するときなど
bool inarea(ll x,ll y){
  return x >= 0 && y >= 0 && x < h && y < w ;
}

//構造体
struct point {
    ll x,y,val;
    point() {}
    point(ll x, ll y, ll val) : x(x), y(y), val(val) {};
};
struct point {
    ll x,y;
    point() {}
    point(ll x, ll y) : x(x), y(y) {};
};
//sort用の比較関数　>なら降順 xの昇順で同じときyの昇順
bool cmp(const point &a, const point &b)
{
  if(a.x == b.x) return a.y < b.y;
  else return a.x < b.x;
}

//bit全探索
d=個数
//0から2^d乗まで
for (ll) bit = 0; bit < (1<<d); ++bit) {
//各ビットを下から見ていく
  rep(j,d){
//jビット目が1なら処理を行う
    if(bit>>j&1){
      todo;
    }
  }
}

//グラフdfs
void dfs(ll x, vector<vector<edge>> &g, bool *see)
{
  //点xに対する処理
  see[x] = 1;
  for (auto p : g[x])
  {
    if (see[p.to])
        continue;
    //進む辺に対する処理（これは木構造でオイラーツアーするために使う）
    dfs(p.to, g, see);
    //戻る辺に対する処理
  }
  //点xの親に戻る時の処理
}

//dfsスタックでやるとき
stack<ll> s;
bool see[n]={};
s.push(0);//スタート
s.push(0);
while(s.size()!=0){
  ll now=s.top();
  s.pop();
  if(!see[now]){
    see[now]=1;
    //訪れた点に対する処理
    for (auto p : g[now])
    {
      if (see[p])
          continue;
      s.push(p);
      s.push(p);
    }
  }
  else{
    //去る点に対する処理
  }
}