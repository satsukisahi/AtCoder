//一次元 t[n]に対して

//構築
vector<ll> s;
s.push_back(0);
rep(i,n){
  s.push_back(t[i]+s[i]);
}

//区間和　t[l]～t[r] 0 ≦ l ≦ r ≦ n-1 0-indexed
s[r+1]-s[l]



//二次元 t[m][n]に対して

//構築
vector<vector<ll>> s(m+1, vector<ll>(n+1,0) );
rep(i,m)rep(j,n){
    s[i+1][j+1]=t[i][j]+s[i][j+1]+s[i+1][j]-s[i][j];
}

//範囲和 右下(x1,y1) 左上(x2,y2) 0-indexed
s[y1+1][x1+1]-s[y1+1][x2]-s[y2][x1+1]+s[y2][x2];