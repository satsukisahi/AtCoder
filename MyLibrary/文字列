string n;

長さ
int len=(int)(n.length());
i文字目
n[i]='X'


数字と文字の混じった入力
int y,m,d;
char st,stt;
cin >> y>> st>> m>> stt>> d;

charの文字数
strlen( char );

数値から文字列
to_string(n);

stringからlonglong
stoll();

1番目から2個の要素を削除(0-indexed)
s.erase(1, 2);

stringの部分文字列
s.substr( 開始位置 最初が0, 取り出す長さ);

//右詰め左詰めゼロ埋め
std::cout << std::right << std::setw(4) <<  12; // "  12"
std::cout << std::left << std::setw(4) <<  12; // "12  "
std::cout << std::setfill('0') << std::right << std::setw(4) << 12; // "0012"
std::cout << std::setfill('0') << std::left  << std::setw(4) << 12; // "1200"

//パターン検索 Z-Algorithm
vector< int > z_algorithm(const string &s) {
  vector< int > prefix(s.size());
  for(int i = 1, j = 0; i < s.size(); i++) {
    if(i + prefix[i - j] < j + prefix[j]) {
      prefix[i] = prefix[i - j];
    } else {
      int k = max(0, j + prefix[j] - i);
      while(i + k < s.size() && s[k] == s[i + k]) ++k;
      prefix[i] = k;
      j = i;
    }
  }
  prefix[0] = (int) s.size();
  return prefix;
}

//sからtを見つけたいとき
//v[t.size()]から値がt.size()のものを探していく　tが単に何個あるか、と何個連続しているか、で処理が異なる(↓のは連続ver)
//abbabbababbabcから連続したabbabを探すとき、前から貪欲にやるとダメ
ll num;//答え
vector< int > v=z_algorithm(t+'|'+s);
ll te=0;
bool see[v.size()]={};
for(ll i=t.size();i<t.size()+s.size()+1;i++){
  if(see[i]){continue;}
  if(v[i]==t.size()){
    ll j=i;
    while(j<t.size()+s.size()+1 && v[j]==t.size()){te++;see[j]=1;j+=t.size();num=max(num,te);}
  }
  else {te=0;see[i]=1;}
}